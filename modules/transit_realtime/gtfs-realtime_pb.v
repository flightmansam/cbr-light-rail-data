// Generated by vproto - Do not modify
module transit_realtime

import vproto

pub struct FeedMessage {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	header FeedHeader
	entity []FeedEntity
}

pub fn (o &FeedMessage) pack() []u8 {
	mut res := []u8{}
	header := zzz_vproto_internal_pack_feedheader(o.header, 1)
	res << header
	unsafe { header.free() }

	// [packed=false]
	for _, x in o.entity {
		res << zzz_vproto_internal_pack_feedentity(x, 2)
	}

	return res
}

pub fn feedmessage_unpack(buf []u8) ?FeedMessage {
	mut res := zzz_vproto_internal_new_feedmessage()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			println('malformed protobuf (couldnt parse tag & wire type)')
			return none
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.header = zzz_vproto_internal_unpack_feedheader(cur_buf, tag_wiretype.wire_type)?
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_feedentity(cur_buf, tag_wiretype.wire_type)?
				res.entity << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			println('malformed protobuf (didnt unpack a field)')
			return none
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_feedmessage() FeedMessage {
	return FeedMessage{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_feedmessage(o FeedMessage, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_feedmessage(buf []u8, tag_wiretype vproto.WireType) ?(int, FeedMessage) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := feedmessage_unpack(v)?
	return i, unpacked
}

@[_allow_multiple_values]
enum FeedHeader_Incrementality {
	full_dataset = 0
	differential = 1
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_new_feedheader_incrementality() FeedHeader_Incrementality {
	return .full_dataset
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_feedheader_incrementality(e FeedHeader_Incrementality, num u32) []u8 {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_feedheader_incrementality_packed(e []FeedHeader_Incrementality, num u32) []u8 {
	x := *(&[]int(&e)) // array{data: e.data, len: e.len, element_size: e.element_size, cap: e.cap}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_feedheader_incrementality(buf []u8, tag_wiretype vproto.WireType) ?(int, FeedHeader_Incrementality) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, unsafe { FeedHeader_Incrementality(v) }
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_feedheader_incrementality_packed(buf []u8, tag_wiretype vproto.WireType) ?(int, []FeedHeader_Incrementality) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	x := *(&[]FeedHeader_Incrementality(&v))
	return i, x // array {data: v.data, len: v.len, cap: v.cap, element_size: v.element_size}
}

pub struct FeedHeader {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	gtfs_realtime_version string
	incrementality        FeedHeader_Incrementality = .full_dataset
	timestamp             u64
}

pub fn (o &FeedHeader) pack() []u8 {
	mut res := []u8{}
	gtfs_realtime_version := vproto.pack_string_field(o.gtfs_realtime_version, 1)
	res << gtfs_realtime_version
	unsafe { gtfs_realtime_version.free() }

	if o.incrementality != zzz_vproto_internal_new_feedheader_incrementality() {
		incrementality := zzz_vproto_internal_pack_feedheader_incrementality(o.incrementality,
			2)
		res << incrementality
		unsafe { incrementality.free() }
	}

	if o.timestamp != u64(0) {
		timestamp := vproto.pack_uint64_field(o.timestamp, 3)
		res << timestamp
		unsafe { timestamp.free() }
	}

	return res
}

pub fn feedheader_unpack(buf []u8) ?FeedHeader {
	mut res := zzz_vproto_internal_new_feedheader()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			println('malformed protobuf (couldnt parse tag & wire type)')
			return none
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.gtfs_realtime_version = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			2 {
				i, res.incrementality = zzz_vproto_internal_unpack_feedheader_incrementality(cur_buf,
					tag_wiretype.wire_type)?
			}
			3 {
				i, res.timestamp = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			println('malformed protobuf (didnt unpack a field)')
			return none
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_feedheader() FeedHeader {
	return FeedHeader{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_feedheader(o FeedHeader, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_feedheader(buf []u8, tag_wiretype vproto.WireType) ?(int, FeedHeader) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := feedheader_unpack(v)?
	return i, unpacked
}

pub struct FeedEntity {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	id          string
	is_deleted  bool
	trip_update TripUpdate
	vehicle     VehiclePosition
	alert       Alert
}

pub fn (o &FeedEntity) pack() []u8 {
	mut res := []u8{}
	id := vproto.pack_string_field(o.id, 1)
	res << id
	unsafe { id.free() }

	if o.is_deleted != false {
		is_deleted := vproto.pack_bool_field(o.is_deleted, 2)
		res << is_deleted
		unsafe { is_deleted.free() }
	}

	if o.trip_update != zzz_vproto_internal_new_tripupdate() {
		trip_update := zzz_vproto_internal_pack_tripupdate(o.trip_update, 3)
		res << trip_update
		unsafe { trip_update.free() }
	}

	if o.vehicle != zzz_vproto_internal_new_vehicleposition() {
		vehicle := zzz_vproto_internal_pack_vehicleposition(o.vehicle, 4)
		res << vehicle
		unsafe { vehicle.free() }
	}

	if o.alert != zzz_vproto_internal_new_alert() {
		alert := zzz_vproto_internal_pack_alert(o.alert, 5)
		res << alert
		unsafe { alert.free() }
	}

	return res
}

pub fn feedentity_unpack(buf []u8) ?FeedEntity {
	mut res := zzz_vproto_internal_new_feedentity()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			println('malformed protobuf (couldnt parse tag & wire type)')
			return none
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.id = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			2 {
				i, res.is_deleted = vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
			}
			3 {
				i, res.trip_update = zzz_vproto_internal_unpack_tripupdate(cur_buf, tag_wiretype.wire_type)?
			}
			4 {
				i, res.vehicle = zzz_vproto_internal_unpack_vehicleposition(cur_buf, tag_wiretype.wire_type)?
			}
			5 {
				i, res.alert = zzz_vproto_internal_unpack_alert(cur_buf, tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			println('malformed protobuf (didnt unpack a field)')
			return none
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_feedentity() FeedEntity {
	return FeedEntity{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_feedentity(o FeedEntity, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_feedentity(buf []u8, tag_wiretype vproto.WireType) ?(int, FeedEntity) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := feedentity_unpack(v)?
	return i, unpacked
}

pub struct TripUpdate_StopTimeEvent {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	delay       int
	time        i64
	uncertainty int
}

pub fn (o &TripUpdate_StopTimeEvent) pack() []u8 {
	mut res := []u8{}
	if o.delay != int(0) {
		delay := vproto.pack_int32_field(o.delay, 1)
		res << delay
		unsafe { delay.free() }
	}

	if o.time != i64(0) {
		time := vproto.pack_int64_field(o.time, 2)
		res << time
		unsafe { time.free() }
	}

	if o.uncertainty != int(0) {
		uncertainty := vproto.pack_int32_field(o.uncertainty, 3)
		res << uncertainty
		unsafe { uncertainty.free() }
	}

	return res
}

pub fn tripupdate_stoptimeevent_unpack(buf []u8) ?TripUpdate_StopTimeEvent {
	mut res := zzz_vproto_internal_new_tripupdate_stoptimeevent()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			println('malformed protobuf (couldnt parse tag & wire type)')
			return none
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.delay = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
			}
			2 {
				i, res.time = vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
			}
			3 {
				i, res.uncertainty = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			println('malformed protobuf (didnt unpack a field)')
			return none
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_tripupdate_stoptimeevent() TripUpdate_StopTimeEvent {
	return TripUpdate_StopTimeEvent{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_tripupdate_stoptimeevent(o TripUpdate_StopTimeEvent, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_tripupdate_stoptimeevent(buf []u8, tag_wiretype vproto.WireType) ?(int, TripUpdate_StopTimeEvent) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := tripupdate_stoptimeevent_unpack(v)?
	return i, unpacked
}

@[_allow_multiple_values]
enum TripUpdateStopTimeUpdate_ScheduleRelationship {
	scheduled = 0
	skipped   = 1
	no_data   = 2
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_new_tripupdatestoptimeupdate_schedulerelationship() TripUpdateStopTimeUpdate_ScheduleRelationship {
	return .scheduled
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_tripupdatestoptimeupdate_schedulerelationship(e TripUpdateStopTimeUpdate_ScheduleRelationship, num u32) []u8 {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_tripupdatestoptimeupdate_schedulerelationship_packed(e []TripUpdateStopTimeUpdate_ScheduleRelationship, num u32) []u8 {
	x := *(&[]int(&e)) // array{data: e.data, len: e.len, element_size: e.element_size, cap: e.cap}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_tripupdatestoptimeupdate_schedulerelationship(buf []u8, tag_wiretype vproto.WireType) ?(int, TripUpdateStopTimeUpdate_ScheduleRelationship) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, unsafe { TripUpdateStopTimeUpdate_ScheduleRelationship(v) }
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_tripupdatestoptimeupdate_schedulerelationship_packed(buf []u8, tag_wiretype vproto.WireType) ?(int, []TripUpdateStopTimeUpdate_ScheduleRelationship) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	x := *(&[]TripUpdateStopTimeUpdate_ScheduleRelationship(&v))
	return i, x // array {data: v.data, len: v.len, cap: v.cap, element_size: v.element_size}
}

pub struct TripUpdate_StopTimeUpdate {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stop_sequence         u32
	stop_id               string
	arrival               TripUpdate_StopTimeEvent
	departure             TripUpdate_StopTimeEvent
	schedule_relationship TripUpdateStopTimeUpdate_ScheduleRelationship = .scheduled
}

pub fn (o &TripUpdate_StopTimeUpdate) pack() []u8 {
	mut res := []u8{}
	if o.stop_sequence != u32(0) {
		stop_sequence := vproto.pack_uint32_field(o.stop_sequence, 1)
		res << stop_sequence
		unsafe { stop_sequence.free() }
	}

	if o.stop_id != '' {
		stop_id := vproto.pack_string_field(o.stop_id, 4)
		res << stop_id
		unsafe { stop_id.free() }
	}

	if o.arrival != zzz_vproto_internal_new_tripupdate_stoptimeevent() {
		arrival := zzz_vproto_internal_pack_tripupdate_stoptimeevent(o.arrival, 2)
		res << arrival
		unsafe { arrival.free() }
	}

	if o.departure != zzz_vproto_internal_new_tripupdate_stoptimeevent() {
		departure := zzz_vproto_internal_pack_tripupdate_stoptimeevent(o.departure, 3)
		res << departure
		unsafe { departure.free() }
	}

	if o.schedule_relationship != zzz_vproto_internal_new_tripupdatestoptimeupdate_schedulerelationship() {
		schedule_relationship := zzz_vproto_internal_pack_tripupdatestoptimeupdate_schedulerelationship(o.schedule_relationship,
			5)
		res << schedule_relationship
		unsafe { schedule_relationship.free() }
	}

	return res
}

pub fn tripupdate_stoptimeupdate_unpack(buf []u8) ?TripUpdate_StopTimeUpdate {
	mut res := zzz_vproto_internal_new_tripupdate_stoptimeupdate()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			println('malformed protobuf (couldnt parse tag & wire type)')
			return none
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.stop_sequence = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
			}
			4 {
				i, res.stop_id = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			2 {
				i, res.arrival = zzz_vproto_internal_unpack_tripupdate_stoptimeevent(cur_buf,
					tag_wiretype.wire_type)?
			}
			3 {
				i, res.departure = zzz_vproto_internal_unpack_tripupdate_stoptimeevent(cur_buf,
					tag_wiretype.wire_type)?
			}
			5 {
				i, res.schedule_relationship = zzz_vproto_internal_unpack_tripupdatestoptimeupdate_schedulerelationship(cur_buf,
					tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			println('malformed protobuf (didnt unpack a field)')
			return none
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_tripupdate_stoptimeupdate() TripUpdate_StopTimeUpdate {
	return TripUpdate_StopTimeUpdate{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_tripupdate_stoptimeupdate(o TripUpdate_StopTimeUpdate, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_tripupdate_stoptimeupdate(buf []u8, tag_wiretype vproto.WireType) ?(int, TripUpdate_StopTimeUpdate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := tripupdate_stoptimeupdate_unpack(v)?
	return i, unpacked
}

pub struct TripUpdate {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	trip             TripDescriptor
	vehicle          VehicleDescriptor
	stop_time_update []TripUpdate_StopTimeUpdate
	timestamp        u64
	delay            int
}

pub fn (o &TripUpdate) pack() []u8 {
	mut res := []u8{}
	trip := zzz_vproto_internal_pack_tripdescriptor(o.trip, 1)
	res << trip
	unsafe { trip.free() }

	if o.vehicle != zzz_vproto_internal_new_vehicledescriptor() {
		vehicle := zzz_vproto_internal_pack_vehicledescriptor(o.vehicle, 3)
		res << vehicle
		unsafe { vehicle.free() }
	}

	// [packed=false]
	for _, x in o.stop_time_update {
		res << zzz_vproto_internal_pack_tripupdate_stoptimeupdate(x, 2)
	}

	if o.timestamp != u64(0) {
		timestamp := vproto.pack_uint64_field(o.timestamp, 4)
		res << timestamp
		unsafe { timestamp.free() }
	}

	if o.delay != int(0) {
		delay := vproto.pack_int32_field(o.delay, 5)
		res << delay
		unsafe { delay.free() }
	}

	return res
}

pub fn tripupdate_unpack(buf []u8) ?TripUpdate {
	mut res := zzz_vproto_internal_new_tripupdate()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			println('malformed protobuf (couldnt parse tag & wire type)')
			return none
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.trip = zzz_vproto_internal_unpack_tripdescriptor(cur_buf, tag_wiretype.wire_type)?
			}
			3 {
				i, res.vehicle = zzz_vproto_internal_unpack_vehicledescriptor(cur_buf,
					tag_wiretype.wire_type)?
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_tripupdate_stoptimeupdate(cur_buf,
					tag_wiretype.wire_type)?
				res.stop_time_update << v
				i = ii
			}
			4 {
				i, res.timestamp = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
			}
			5 {
				i, res.delay = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			println('malformed protobuf (didnt unpack a field)')
			return none
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_tripupdate() TripUpdate {
	return TripUpdate{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_tripupdate(o TripUpdate, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_tripupdate(buf []u8, tag_wiretype vproto.WireType) ?(int, TripUpdate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := tripupdate_unpack(v)?
	return i, unpacked
}

@[_allow_multiple_values]
pub enum VehiclePosition_VehicleStopStatus {
	incoming_at   = 0
	stopped_at    = 1
	in_transit_to = 2
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_new_vehicleposition_vehiclestopstatus() VehiclePosition_VehicleStopStatus {
	return .incoming_at
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_vehicleposition_vehiclestopstatus(e VehiclePosition_VehicleStopStatus, num u32) []u8 {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_vehicleposition_vehiclestopstatus_packed(e []VehiclePosition_VehicleStopStatus, num u32) []u8 {
	x := *(&[]int(&e)) // array{data: e.data, len: e.len, element_size: e.element_size, cap: e.cap}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_vehicleposition_vehiclestopstatus(buf []u8, tag_wiretype vproto.WireType) ?(int, VehiclePosition_VehicleStopStatus) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, unsafe { VehiclePosition_VehicleStopStatus(v) }
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_vehicleposition_vehiclestopstatus_packed(buf []u8, tag_wiretype vproto.WireType) ?(int, []VehiclePosition_VehicleStopStatus) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	x := *(&[]VehiclePosition_VehicleStopStatus(&v))
	return i, x // array {data: v.data, len: v.len, cap: v.cap, element_size: v.element_size}
}

@[_allow_multiple_values]
enum VehiclePosition_CongestionLevel {
	unknown_congestion_level = 0
	running_smoothly         = 1
	stop_and_go              = 2
	congestion               = 3
	severe_congestion        = 4
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_new_vehicleposition_congestionlevel() VehiclePosition_CongestionLevel {
	return .unknown_congestion_level
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_vehicleposition_congestionlevel(e VehiclePosition_CongestionLevel, num u32) []u8 {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_vehicleposition_congestionlevel_packed(e []VehiclePosition_CongestionLevel, num u32) []u8 {
	x := *(&[]int(&e)) // array{data: e.data, len: e.len, element_size: e.element_size, cap: e.cap}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_vehicleposition_congestionlevel(buf []u8, tag_wiretype vproto.WireType) ?(int, VehiclePosition_CongestionLevel) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, unsafe { VehiclePosition_CongestionLevel(v) }
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_vehicleposition_congestionlevel_packed(buf []u8, tag_wiretype vproto.WireType) ?(int, []VehiclePosition_CongestionLevel) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	x := *(&[]VehiclePosition_CongestionLevel(&v))
	return i, x // array {data: v.data, len: v.len, cap: v.cap, element_size: v.element_size}
}

@[_allow_multiple_values]
enum VehiclePosition_OccupancyStatus {
	empty                      = 0
	many_seats_available       = 1
	few_seats_available        = 2
	standing_room_only         = 3
	crushed_standing_room_only = 4
	full                       = 5
	not_accepting_passengers   = 6
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_new_vehicleposition_occupancystatus() VehiclePosition_OccupancyStatus {
	return .empty
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_vehicleposition_occupancystatus(e VehiclePosition_OccupancyStatus, num u32) []u8 {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_vehicleposition_occupancystatus_packed(e []VehiclePosition_OccupancyStatus, num u32) []u8 {
	x := *(&[]int(&e)) // array{data: e.data, len: e.len, element_size: e.element_size, cap: e.cap}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_vehicleposition_occupancystatus(buf []u8, tag_wiretype vproto.WireType) ?(int, VehiclePosition_OccupancyStatus) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, unsafe { VehiclePosition_OccupancyStatus(v) }
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_vehicleposition_occupancystatus_packed(buf []u8, tag_wiretype vproto.WireType) ?(int, []VehiclePosition_OccupancyStatus) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	x := *(&[]VehiclePosition_OccupancyStatus(&v))
	return i, x // array {data: v.data, len: v.len, cap: v.cap, element_size: v.element_size}
}

pub struct VehiclePosition {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	trip                  TripDescriptor
	vehicle               VehicleDescriptor
	position              Position
	current_stop_sequence u32
	stop_id               string
	current_status        VehiclePosition_VehicleStopStatus = .in_transit_to
	timestamp             u64
	congestion_level      VehiclePosition_CongestionLevel
	occupancy_status      VehiclePosition_OccupancyStatus
}

pub fn (o &VehiclePosition) pack() []u8 {
	mut res := []u8{}
	if o.trip != zzz_vproto_internal_new_tripdescriptor() {
		trip := zzz_vproto_internal_pack_tripdescriptor(o.trip, 1)
		res << trip
		unsafe { trip.free() }
	}

	if o.vehicle != zzz_vproto_internal_new_vehicledescriptor() {
		vehicle := zzz_vproto_internal_pack_vehicledescriptor(o.vehicle, 8)
		res << vehicle
		unsafe { vehicle.free() }
	}

	if o.position != zzz_vproto_internal_new_position() {
		position := zzz_vproto_internal_pack_position(o.position, 2)
		res << position
		unsafe { position.free() }
	}

	if o.current_stop_sequence != u32(0) {
		current_stop_sequence := vproto.pack_uint32_field(o.current_stop_sequence, 3)
		res << current_stop_sequence
		unsafe { current_stop_sequence.free() }
	}

	if o.stop_id != '' {
		stop_id := vproto.pack_string_field(o.stop_id, 7)
		res << stop_id
		unsafe { stop_id.free() }
	}

	if o.current_status != zzz_vproto_internal_new_vehicleposition_vehiclestopstatus() {
		current_status := zzz_vproto_internal_pack_vehicleposition_vehiclestopstatus(o.current_status,
			4)
		res << current_status
		unsafe { current_status.free() }
	}

	if o.timestamp != u64(0) {
		timestamp := vproto.pack_uint64_field(o.timestamp, 5)
		res << timestamp
		unsafe { timestamp.free() }
	}

	if o.congestion_level != zzz_vproto_internal_new_vehicleposition_congestionlevel() {
		congestion_level := zzz_vproto_internal_pack_vehicleposition_congestionlevel(o.congestion_level,
			6)
		res << congestion_level
		unsafe { congestion_level.free() }
	}

	if o.occupancy_status != zzz_vproto_internal_new_vehicleposition_occupancystatus() {
		occupancy_status := zzz_vproto_internal_pack_vehicleposition_occupancystatus(o.occupancy_status,
			9)
		res << occupancy_status
		unsafe { occupancy_status.free() }
	}

	return res
}

pub fn vehicleposition_unpack(buf []u8) ?VehiclePosition {
	mut res := zzz_vproto_internal_new_vehicleposition()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			println('malformed protobuf (couldnt parse tag & wire type)')
			return none
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.trip = zzz_vproto_internal_unpack_tripdescriptor(cur_buf, tag_wiretype.wire_type)?
			}
			8 {
				i, res.vehicle = zzz_vproto_internal_unpack_vehicledescriptor(cur_buf,
					tag_wiretype.wire_type)?
			}
			2 {
				i, res.position = zzz_vproto_internal_unpack_position(cur_buf, tag_wiretype.wire_type)?
			}
			3 {
				i, res.current_stop_sequence = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
			}
			7 {
				i, res.stop_id = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			4 {
				i, res.current_status = zzz_vproto_internal_unpack_vehicleposition_vehiclestopstatus(cur_buf,
					tag_wiretype.wire_type)?
			}
			5 {
				i, res.timestamp = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
			}
			6 {
				i, res.congestion_level = zzz_vproto_internal_unpack_vehicleposition_congestionlevel(cur_buf,
					tag_wiretype.wire_type)?
			}
			9 {
				i, res.occupancy_status = zzz_vproto_internal_unpack_vehicleposition_occupancystatus(cur_buf,
					tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			println('malformed protobuf (didnt unpack a field)')
			return none
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_vehicleposition() VehiclePosition {
	return VehiclePosition{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_vehicleposition(o VehiclePosition, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_vehicleposition(buf []u8, tag_wiretype vproto.WireType) ?(int, VehiclePosition) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := vehicleposition_unpack(v)?
	return i, unpacked
}

@[_allow_multiple_values]
enum Alert_Cause {
	unknown_cause     = 1
	other_cause       = 2
	technical_problem = 3
	strike            = 4
	demonstration     = 5
	accident          = 6
	holiday           = 7
	weather           = 8
	maintenance       = 9
	construction      = 10
	police_activity   = 11
	medical_emergency = 12
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_new_alert_cause() Alert_Cause {
	return .unknown_cause
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_alert_cause(e Alert_Cause, num u32) []u8 {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_alert_cause_packed(e []Alert_Cause, num u32) []u8 {
	x := *(&[]int(&e)) // array{data: e.data, len: e.len, element_size: e.element_size, cap: e.cap}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_alert_cause(buf []u8, tag_wiretype vproto.WireType) ?(int, Alert_Cause) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, unsafe { Alert_Cause(v) }
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_alert_cause_packed(buf []u8, tag_wiretype vproto.WireType) ?(int, []Alert_Cause) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	x := *(&[]Alert_Cause(&v))
	return i, x // array {data: v.data, len: v.len, cap: v.cap, element_size: v.element_size}
}

@[_allow_multiple_values]
enum Alert_Effect {
	no_service         = 1
	reduced_service    = 2
	significant_delays = 3
	detour             = 4
	additional_service = 5
	modified_service   = 6
	other_effect       = 7
	unknown_effect     = 8
	stop_moved         = 9
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_new_alert_effect() Alert_Effect {
	return .no_service
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_alert_effect(e Alert_Effect, num u32) []u8 {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_alert_effect_packed(e []Alert_Effect, num u32) []u8 {
	x := *(&[]int(&e)) // array{data: e.data, len: e.len, element_size: e.element_size, cap: e.cap}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_alert_effect(buf []u8, tag_wiretype vproto.WireType) ?(int, Alert_Effect) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, unsafe { Alert_Effect(v) }
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_alert_effect_packed(buf []u8, tag_wiretype vproto.WireType) ?(int, []Alert_Effect) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	x := *(&[]Alert_Effect(&v))
	return i, x // array {data: v.data, len: v.len, cap: v.cap, element_size: v.element_size}
}

pub struct Alert {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	active_period    []TimeRange
	informed_entity  []EntitySelector
	cause            Alert_Cause  = .unknown_cause
	effect           Alert_Effect = .unknown_effect
	url              TranslatedString
	header_text      TranslatedString
	description_text TranslatedString
}

pub fn (o &Alert) pack() []u8 {
	mut res := []u8{}
	// [packed=false]
	for _, x in o.active_period {
		res << zzz_vproto_internal_pack_timerange(x, 1)
	}

	// [packed=false]
	for _, x in o.informed_entity {
		res << zzz_vproto_internal_pack_entityselector(x, 5)
	}

	if o.cause != zzz_vproto_internal_new_alert_cause() {
		cause := zzz_vproto_internal_pack_alert_cause(o.cause, 6)
		res << cause
		unsafe { cause.free() }
	}

	if o.effect != zzz_vproto_internal_new_alert_effect() {
		effect := zzz_vproto_internal_pack_alert_effect(o.effect, 7)
		res << effect
		unsafe { effect.free() }
	}

	if o.url != zzz_vproto_internal_new_translatedstring() {
		url := zzz_vproto_internal_pack_translatedstring(o.url, 8)
		res << url
		unsafe { url.free() }
	}

	if o.header_text != zzz_vproto_internal_new_translatedstring() {
		header_text := zzz_vproto_internal_pack_translatedstring(o.header_text, 10)
		res << header_text
		unsafe { header_text.free() }
	}

	if o.description_text != zzz_vproto_internal_new_translatedstring() {
		description_text := zzz_vproto_internal_pack_translatedstring(o.description_text,
			11)
		res << description_text
		unsafe { description_text.free() }
	}

	return res
}

pub fn alert_unpack(buf []u8) ?Alert {
	mut res := zzz_vproto_internal_new_alert()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			println('malformed protobuf (couldnt parse tag & wire type)')
			return none
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_timerange(cur_buf, tag_wiretype.wire_type)?
				res.active_period << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_entityselector(cur_buf, tag_wiretype.wire_type)?
				res.informed_entity << v
				i = ii
			}
			6 {
				i, res.cause = zzz_vproto_internal_unpack_alert_cause(cur_buf, tag_wiretype.wire_type)?
			}
			7 {
				i, res.effect = zzz_vproto_internal_unpack_alert_effect(cur_buf, tag_wiretype.wire_type)?
			}
			8 {
				i, res.url = zzz_vproto_internal_unpack_translatedstring(cur_buf, tag_wiretype.wire_type)?
			}
			10 {
				i, res.header_text = zzz_vproto_internal_unpack_translatedstring(cur_buf,
					tag_wiretype.wire_type)?
			}
			11 {
				i, res.description_text = zzz_vproto_internal_unpack_translatedstring(cur_buf,
					tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			println('malformed protobuf (didnt unpack a field)')
			return none
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_alert() Alert {
	return Alert{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_alert(o Alert, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_alert(buf []u8, tag_wiretype vproto.WireType) ?(int, Alert) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := alert_unpack(v)?
	return i, unpacked
}

pub struct TimeRange {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	start u64
	end   u64
}

pub fn (o &TimeRange) pack() []u8 {
	mut res := []u8{}
	if o.start != u64(0) {
		start := vproto.pack_uint64_field(o.start, 1)
		res << start
		unsafe { start.free() }
	}

	if o.end != u64(0) {
		end := vproto.pack_uint64_field(o.end, 2)
		res << end
		unsafe { end.free() }
	}

	return res
}

pub fn timerange_unpack(buf []u8) ?TimeRange {
	mut res := zzz_vproto_internal_new_timerange()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			println('malformed protobuf (couldnt parse tag & wire type)')
			return none
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.start = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
			}
			2 {
				i, res.end = vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			println('malformed protobuf (didnt unpack a field)')
			return none
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_timerange() TimeRange {
	return TimeRange{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_timerange(o TimeRange, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_timerange(buf []u8, tag_wiretype vproto.WireType) ?(int, TimeRange) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := timerange_unpack(v)?
	return i, unpacked
}

pub struct Position {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	latitude  f32
	longitude f32
	bearing   f32
	odometer  f64
	speed     f32
}

pub fn (o &Position) pack() []u8 {
	mut res := []u8{}
	latitude := vproto.pack_float_field(o.latitude, 1)
	res << latitude
	unsafe { latitude.free() }

	longitude := vproto.pack_float_field(o.longitude, 2)
	res << longitude
	unsafe { longitude.free() }

	if o.bearing != f32(0) {
		bearing := vproto.pack_float_field(o.bearing, 3)
		res << bearing
		unsafe { bearing.free() }
	}

	if o.odometer != f64(0) {
		odometer := vproto.pack_double_field(o.odometer, 4)
		res << odometer
		unsafe { odometer.free() }
	}

	if o.speed != f32(0) {
		speed := vproto.pack_float_field(o.speed, 5)
		res << speed
		unsafe { speed.free() }
	}

	return res
}

pub fn position_unpack(buf []u8) ?Position {
	mut res := zzz_vproto_internal_new_position()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			println('malformed protobuf (couldnt parse tag & wire type)')
			return none
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.latitude = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
			}
			2 {
				i, res.longitude = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
			}
			3 {
				i, res.bearing = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
			}
			4 {
				i, res.odometer = vproto.unpack_double_field(cur_buf, tag_wiretype.wire_type)?
			}
			5 {
				i, res.speed = vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			println('malformed protobuf (didnt unpack a field)')
			return none
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_position() Position {
	return Position{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_position(o Position, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_position(buf []u8, tag_wiretype vproto.WireType) ?(int, Position) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := position_unpack(v)?
	return i, unpacked
}

@[_allow_multiple_values]
enum TripDescriptor_ScheduleRelationship {
	scheduled   = 0
	added       = 1
	unscheduled = 2
	canceled    = 3
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_new_tripdescriptor_schedulerelationship() TripDescriptor_ScheduleRelationship {
	return .scheduled
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_tripdescriptor_schedulerelationship(e TripDescriptor_ScheduleRelationship, num u32) []u8 {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_tripdescriptor_schedulerelationship_packed(e []TripDescriptor_ScheduleRelationship, num u32) []u8 {
	x := *(&[]int(&e)) // array{data: e.data, len: e.len, element_size: e.element_size, cap: e.cap}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_tripdescriptor_schedulerelationship(buf []u8, tag_wiretype vproto.WireType) ?(int, TripDescriptor_ScheduleRelationship) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, unsafe { TripDescriptor_ScheduleRelationship(v) }
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_tripdescriptor_schedulerelationship_packed(buf []u8, tag_wiretype vproto.WireType) ?(int, []TripDescriptor_ScheduleRelationship) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	x := *(&[]TripDescriptor_ScheduleRelationship(&v))
	return i, x // array {data: v.data, len: v.len, cap: v.cap, element_size: v.element_size}
}

pub struct TripDescriptor {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	trip_id               string
	route_id              string
	direction_id          u32
	start_time            string
	start_date            string
	schedule_relationship TripDescriptor_ScheduleRelationship
}

pub fn (o &TripDescriptor) pack() []u8 {
	mut res := []u8{}
	if o.trip_id != '' {
		trip_id := vproto.pack_string_field(o.trip_id, 1)
		res << trip_id
		unsafe { trip_id.free() }
	}

	if o.route_id != '' {
		route_id := vproto.pack_string_field(o.route_id, 5)
		res << route_id
		unsafe { route_id.free() }
	}

	if o.direction_id != u32(0) {
		direction_id := vproto.pack_uint32_field(o.direction_id, 6)
		res << direction_id
		unsafe { direction_id.free() }
	}

	if o.start_time != '' {
		start_time := vproto.pack_string_field(o.start_time, 2)
		res << start_time
		unsafe { start_time.free() }
	}

	if o.start_date != '' {
		start_date := vproto.pack_string_field(o.start_date, 3)
		res << start_date
		unsafe { start_date.free() }
	}

	if o.schedule_relationship != zzz_vproto_internal_new_tripdescriptor_schedulerelationship() {
		schedule_relationship := zzz_vproto_internal_pack_tripdescriptor_schedulerelationship(o.schedule_relationship,
			4)
		res << schedule_relationship
		unsafe { schedule_relationship.free() }
	}

	return res
}

pub fn tripdescriptor_unpack(buf []u8) ?TripDescriptor {
	mut res := zzz_vproto_internal_new_tripdescriptor()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			println('malformed protobuf (couldnt parse tag & wire type)')
			return none
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.trip_id = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			5 {
				i, res.route_id = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			6 {
				i, res.direction_id = vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
			}
			2 {
				i, res.start_time = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			3 {
				i, res.start_date = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			4 {
				i, res.schedule_relationship = zzz_vproto_internal_unpack_tripdescriptor_schedulerelationship(cur_buf,
					tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			println('malformed protobuf (didnt unpack a field)')
			return none
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_tripdescriptor() TripDescriptor {
	return TripDescriptor{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_tripdescriptor(o TripDescriptor, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_tripdescriptor(buf []u8, tag_wiretype vproto.WireType) ?(int, TripDescriptor) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := tripdescriptor_unpack(v)?
	return i, unpacked
}

pub struct VehicleDescriptor {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	id            string
	label         string
	license_plate string
}

pub fn (o &VehicleDescriptor) pack() []u8 {
	mut res := []u8{}
	if o.id != '' {
		id := vproto.pack_string_field(o.id, 1)
		res << id
		unsafe { id.free() }
	}

	if o.label != '' {
		label := vproto.pack_string_field(o.label, 2)
		res << label
		unsafe { label.free() }
	}

	if o.license_plate != '' {
		license_plate := vproto.pack_string_field(o.license_plate, 3)
		res << license_plate
		unsafe { license_plate.free() }
	}

	return res
}

pub fn vehicledescriptor_unpack(buf []u8) ?VehicleDescriptor {
	mut res := zzz_vproto_internal_new_vehicledescriptor()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			println('malformed protobuf (couldnt parse tag & wire type)')
			return none
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.id = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			2 {
				i, res.label = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			3 {
				i, res.license_plate = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			println('malformed protobuf (didnt unpack a field)')
			return none
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_vehicledescriptor() VehicleDescriptor {
	return VehicleDescriptor{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_vehicledescriptor(o VehicleDescriptor, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_vehicledescriptor(buf []u8, tag_wiretype vproto.WireType) ?(int, VehicleDescriptor) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := vehicledescriptor_unpack(v)?
	return i, unpacked
}

pub struct EntitySelector {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	agency_id  string
	route_id   string
	route_type int
	trip       TripDescriptor
	stop_id    string
}

pub fn (o &EntitySelector) pack() []u8 {
	mut res := []u8{}
	if o.agency_id != '' {
		agency_id := vproto.pack_string_field(o.agency_id, 1)
		res << agency_id
		unsafe { agency_id.free() }
	}

	if o.route_id != '' {
		route_id := vproto.pack_string_field(o.route_id, 2)
		res << route_id
		unsafe { route_id.free() }
	}

	if o.route_type != int(0) {
		route_type := vproto.pack_int32_field(o.route_type, 3)
		res << route_type
		unsafe { route_type.free() }
	}

	if o.trip != zzz_vproto_internal_new_tripdescriptor() {
		trip := zzz_vproto_internal_pack_tripdescriptor(o.trip, 4)
		res << trip
		unsafe { trip.free() }
	}

	if o.stop_id != '' {
		stop_id := vproto.pack_string_field(o.stop_id, 5)
		res << stop_id
		unsafe { stop_id.free() }
	}

	return res
}

pub fn entityselector_unpack(buf []u8) ?EntitySelector {
	mut res := zzz_vproto_internal_new_entityselector()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			println('malformed protobuf (couldnt parse tag & wire type)')
			return none
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.agency_id = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			2 {
				i, res.route_id = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			3 {
				i, res.route_type = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
			}
			4 {
				i, res.trip = zzz_vproto_internal_unpack_tripdescriptor(cur_buf, tag_wiretype.wire_type)?
			}
			5 {
				i, res.stop_id = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			println('malformed protobuf (didnt unpack a field)')
			return none
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_entityselector() EntitySelector {
	return EntitySelector{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_entityselector(o EntitySelector, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_entityselector(buf []u8, tag_wiretype vproto.WireType) ?(int, EntitySelector) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := entityselector_unpack(v)?
	return i, unpacked
}

pub struct TranslatedString_Translation {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	text     string
	language string
}

pub fn (o &TranslatedString_Translation) pack() []u8 {
	mut res := []u8{}
	text := vproto.pack_string_field(o.text, 1)
	res << text
	unsafe { text.free() }

	if o.language != '' {
		language := vproto.pack_string_field(o.language, 2)
		res << language
		unsafe { language.free() }
	}

	return res
}

pub fn translatedstring_translation_unpack(buf []u8) ?TranslatedString_Translation {
	mut res := zzz_vproto_internal_new_translatedstring_translation()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			println('malformed protobuf (couldnt parse tag & wire type)')
			return none
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.text = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			2 {
				i, res.language = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			println('malformed protobuf (didnt unpack a field)')
			return none
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_translatedstring_translation() TranslatedString_Translation {
	return TranslatedString_Translation{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_translatedstring_translation(o TranslatedString_Translation, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_translatedstring_translation(buf []u8, tag_wiretype vproto.WireType) ?(int, TranslatedString_Translation) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := translatedstring_translation_unpack(v)?
	return i, unpacked
}

pub struct TranslatedString {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	translation []TranslatedString_Translation
}

pub fn (o &TranslatedString) pack() []u8 {
	mut res := []u8{}
	// [packed=false]
	for _, x in o.translation {
		res << zzz_vproto_internal_pack_translatedstring_translation(x, 1)
	}

	return res
}

pub fn translatedstring_unpack(buf []u8) ?TranslatedString {
	mut res := zzz_vproto_internal_new_translatedstring()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			println('malformed protobuf (couldnt parse tag & wire type)')
			return none
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_translatedstring_translation(cur_buf,
					tag_wiretype.wire_type)?
				res.translation << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			println('malformed protobuf (didnt unpack a field)')
			return none
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_translatedstring() TranslatedString {
	return TranslatedString{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_translatedstring(o TranslatedString, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_translatedstring(buf []u8, tag_wiretype vproto.WireType) ?(int, TranslatedString) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := translatedstring_unpack(v)?
	return i, unpacked
}
