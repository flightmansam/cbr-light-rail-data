// Generated by vproto - Do not modify
module vproto_test

import emily33901.vproto

pub struct TestMapFields {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	map1       map[string]int
	complexmap map[string]TestMapFields
}

pub fn (o &TestMapFields) pack() []u8 {
	mut res := []u8{}
	for k, v in o.map1 {
		mut bytes := vproto.pack_string_field(k, 1)
		bytes << vproto.pack_int32_field(v, 2)
		res << vproto.pack_bytes_field(bytes, 1)
	}

	for k, v in o.complexmap {
		mut bytes := vproto.pack_string_field(k, 1)
		bytes << zzz_vproto_internal_pack_testmapfields(v, 2)
		res << vproto.pack_bytes_field(bytes, 2)
	}

	return res
}

pub fn testmapfields_unpack(buf []u8) ?TestMapFields {
	mut res := zzz_vproto_internal_new_testmapfields()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, bytes := vproto.unpack_message_field(cur_buf, tag_wiretype.wire_type)?
				mut k := ''

				mut v := int(0)
				mut bytes_offset := 0
				for j := 0; j < 2; j++ {
					map_tag_wiretype := vproto.unpack_tag_wire_type(bytes[bytes_offset..]) or {
						return error('malformed protobuf (couldnt parse tag & wire type)')
					}
					bytes_offset += map_tag_wiretype.consumed
					match map_tag_wiretype.tag {
						1 {
							map_ii, kk := vproto.unpack_string_field(bytes[bytes_offset..],
								map_tag_wiretype.wire_type)?
							bytes_offset += map_ii
							k = kk
						}
						2 {
							map_ii, vv := vproto.unpack_int32_field(bytes[bytes_offset..],
								map_tag_wiretype.wire_type)?
							bytes_offset += map_ii
							v = vv
						}
						else {
							return error('malformed map field (didnt unpack a key/value)')
						}
					}
				}
				res.map1[k] = v
				i = ii
			}
			2 {
				ii, bytes := vproto.unpack_message_field(cur_buf, tag_wiretype.wire_type)?
				mut k := ''

				mut v := zzz_vproto_internal_new_testmapfields()
				mut bytes_offset := 0
				for j := 0; j < 2; j++ {
					map_tag_wiretype := vproto.unpack_tag_wire_type(bytes[bytes_offset..]) or {
						return error('malformed protobuf (couldnt parse tag & wire type)')
					}
					bytes_offset += map_tag_wiretype.consumed
					match map_tag_wiretype.tag {
						1 {
							map_ii, kk := vproto.unpack_string_field(bytes[bytes_offset..],
								map_tag_wiretype.wire_type)?
							bytes_offset += map_ii
							k = kk
						}
						2 {
							map_ii, vv := zzz_vproto_internal_unpack_testmapfields(bytes[bytes_offset..],
								map_tag_wiretype.wire_type)?
							bytes_offset += map_ii
							v = vv
						}
						else {
							return error('malformed map field (didnt unpack a key/value)')
						}
					}
				}
				res.complexmap[k] = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_testmapfields() TestMapFields {
	return TestMapFields{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_testmapfields(o TestMapFields, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_testmapfields(buf []u8, tag_wiretype vproto.WireType) ?(int, TestMapFields) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := testmapfields_unpack(v)?
	return i, unpacked
}
