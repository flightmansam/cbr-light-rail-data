// Generated by vproto - Do not modify
module vproto_test

import emily33901.vproto

pub struct PersonPhoneNumber_Comment {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	comment string
}

pub fn (o &PersonPhoneNumber_Comment) pack() []u8 {
	mut res := []u8{}
	comment := vproto.pack_string_field(o.comment, 1)
	res << comment
	unsafe { comment.free() }

	return res
}

pub fn personphonenumber_comment_unpack(buf []u8) ?PersonPhoneNumber_Comment {
	mut res := zzz_vproto_internal_new_personphonenumber_comment()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.comment = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_personphonenumber_comment() PersonPhoneNumber_Comment {
	return PersonPhoneNumber_Comment{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_personphonenumber_comment(o PersonPhoneNumber_Comment, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_personphonenumber_comment(buf []u8, tag_wiretype vproto.WireType) ?(int, PersonPhoneNumber_Comment) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := personphonenumber_comment_unpack(v)?
	return i, unpacked
}

pub struct Person_PhoneNumber {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	number  string
	@type   Person_PhoneType = .home
	comment PersonPhoneNumber_Comment
}

pub fn (o &Person_PhoneNumber) pack() []u8 {
	mut res := []u8{}
	number := vproto.pack_string_field(o.number, 1)
	res << number
	unsafe { number.free() }

	if o.@type != zzz_vproto_internal_new_person_phonetype() {
		@type := zzz_vproto_internal_pack_person_phonetype(o.@type, 2)
		res << @type
		unsafe { @type.free() }
	}

	if o.comment != zzz_vproto_internal_new_personphonenumber_comment() {
		comment := zzz_vproto_internal_pack_personphonenumber_comment(o.comment, 3)
		res << comment
		unsafe { comment.free() }
	}

	return res
}

pub fn person_phonenumber_unpack(buf []u8) ?Person_PhoneNumber {
	mut res := zzz_vproto_internal_new_person_phonenumber()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.number = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			2 {
				i, res.@type = zzz_vproto_internal_unpack_person_phonetype(cur_buf, tag_wiretype.wire_type)?
			}
			3 {
				i, res.comment = zzz_vproto_internal_unpack_personphonenumber_comment(cur_buf,
					tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_person_phonenumber() Person_PhoneNumber {
	return Person_PhoneNumber{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_person_phonenumber(o Person_PhoneNumber, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_person_phonenumber(buf []u8, tag_wiretype vproto.WireType) ?(int, Person_PhoneNumber) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := person_phonenumber_unpack(v)?
	return i, unpacked
}

@[_allow_multiple_values]
enum Person_PhoneType {
	mobile = 0
	home   = 1
	work   = 2
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_new_person_phonetype() Person_PhoneType {
	return .mobile
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_person_phonetype(e Person_PhoneType, num u32) []u8 {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_pack_person_phonetype_packed(e []Person_PhoneType, num u32) []u8 {
	x := *(&[]i32(&e)) // array{data: e.data, len: e.len, element_size: e.element_size, cap: e.cap}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_person_phonetype(buf []u8, tag_wiretype vproto.WireType) ?(int, Person_PhoneType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, Person_PhoneType(v)
}

// FOR INTERNAL USE ONLY
@[inline]
fn zzz_vproto_internal_unpack_person_phonetype_packed(buf []u8, tag_wiretype vproto.WireType) ?(int, []Person_PhoneType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	x := *(&[]Person_PhoneType(&v))
	return i, x // array {data: v.data, len: v.len, cap: v.cap, element_size: v.element_size}
}

pub struct Person {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name  string
	id    int
	email string
	phone []Person_PhoneNumber
}

pub fn (o &Person) pack() []u8 {
	mut res := []u8{}
	name := vproto.pack_string_field(o.name, 1)
	res << name
	unsafe { name.free() }

	id := vproto.pack_int32_field(o.id, 2)
	res << id
	unsafe { id.free() }

	if o.email != '' {
		email := vproto.pack_string_field(o.email, 3)
		res << email
		unsafe { email.free() }
	}

	// [packed=false]
	for _, x in o.phone {
		res << zzz_vproto_internal_pack_person_phonenumber(x, 4)
	}

	return res
}

pub fn person_unpack(buf []u8) ?Person {
	mut res := zzz_vproto_internal_new_person()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			2 {
				i, res.id = vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
			}
			3 {
				i, res.email = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_person_phonenumber(cur_buf, tag_wiretype.wire_type)?
				res.phone << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_person() Person {
	return Person{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_person(o Person, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_person(buf []u8, tag_wiretype vproto.WireType) ?(int, Person) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := person_unpack(v)?
	return i, unpacked
}

pub struct LookupResult {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	person Person
}

pub fn (o &LookupResult) pack() []u8 {
	mut res := []u8{}
	if o.person != zzz_vproto_internal_new_person() {
		person := zzz_vproto_internal_pack_person(o.person, 1)
		res << person
		unsafe { person.free() }
	}

	return res
}

pub fn lookupresult_unpack(buf []u8) ?LookupResult {
	mut res := zzz_vproto_internal_new_lookupresult()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.person = zzz_vproto_internal_unpack_person(cur_buf, tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_lookupresult() LookupResult {
	return LookupResult{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_lookupresult(o LookupResult, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_lookupresult(buf []u8, tag_wiretype vproto.WireType) ?(int, LookupResult) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := lookupresult_unpack(v)?
	return i, unpacked
}

pub struct Name {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name string
}

pub fn (o &Name) pack() []u8 {
	mut res := []u8{}
	if o.name != '' {
		name := vproto.pack_string_field(o.name, 1)
		res << name
		unsafe { name.free() }
	}

	return res
}

pub fn name_unpack(buf []u8) ?Name {
	mut res := zzz_vproto_internal_new_name()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				i, res.name = vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_new_name() Name {
	return Name{}
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_pack_name(o Name, num u32) []u8 {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
@[inline]
pub fn zzz_vproto_internal_unpack_name(buf []u8, tag_wiretype vproto.WireType) ?(int, Name) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := name_unpack(v)?
	return i, unpacked
}
